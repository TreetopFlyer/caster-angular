<!DOCTYPE html>
<html>
    <head>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular-route.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular-animate.min.js"></script>
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <style>
            *
            {
                font-family: Arial;
            }
            dl.Player
            {
                width:200px;
                float:left;
                border:2px solid #ddd;
            }
            dl.Player.Active, tr.Selected
            {
                background:#FA0;
            }
            dl.Player.Targeted
            {
                border:2px dotted #F00;
            }

            td
            {
                padding:0.5rem;
            }
            th
            {
                border-bottom:1px solid #ddd;
            }

        </style>
    </head>
    <body>
        <div ng-app="Game" ng-controller="GameController">

            <div>
                <h4>Round: {{Round.Epoch}} Turn: {{Round.Index}}</h4>
            </div>

            <div>
                <h4>Current Player</h4>
                <button ng-click="Round.Advance()">End Turn</button>
                <table>
                    <tr>
                        <th><i class="material-icons">equalizer</i></th>
                        <th><i class="material-icons">whatshot</i></th>
                        <th><i class="material-icons">&#xE192;</i></th>
                        <th><i class="material-icons">flash_on</i></th>
                        <th><i class="material-icons">pan_tool</i></th>
                    </tr>
                    <tr ng-repeat="Ability in Round.Player.Abilities" ng-class="{Selected: Ability.Selected}">
                        <td>{{Ability.Deltas}}</td>
                        <td>{{Ability.Power}}</td>
                        <td>{{Ability.Duration}}</td>
                        <td>
                            {{Ability.Charges.Value}} / {{Ability.Charges.Max}}
                            
                        </td>
                        <td>
                            <button ng-hide="Ability.Charges.Value == Ability.Charges.Max || Round.Player.Energy.Value == 0" ng-click="Round.Player.QueueCharge(Ability)">Charge <i class="material-icons">&#xE8E5;</i></button>
                            <button ng-hide="Ability.Selected || Ability.Charges.Value == 0 || Round.Player.Energy.Value == 0" ng-click="Selection.Start(Ability)">Select Targets <i class="material-icons">&#xE1B4;</i></button> 

                            <button ng-show="Ability.Selected && Selection.Targets.length > 0" ng-click="Round.Player.QueueCast(Ability, Selection.Targets); Selection.Stop();">Cast <i class="material-icons">flare</i></button> 
                            <button ng-show="Ability.Selected" ng-click="Selection.Stop()">Cancel <i class="material-icons">&#xE1B5;</i></button> 
                        </td>
                    </tr>
                </table>
                <hr/>
                <div ng-hide="Round.Player.Queue.length == 0">
                    <button ng-click="Round.Player.QueuePop()">Undo Last</button>
                </div>
                <ul>
                    <li ng-repeat="Thing in Round.Player.Queue track by $index">
                        <span>{{Thing.Meta.Message}}</span>
                    </li>
                </ul>
                <div ng-hide="Round.Player.Queue.length == 0">
                    <button ng-click="">Commit All</button>
                </div>
                <hr/>
            </div>

            <div>
                <h4>Players</h4>
                <dl ng-repeat="Player in Players" class="Player" ng-click="Selection.Toggle(Player)" ng-class="{Active: Player.Active, Targeted: Player.Targeted}">
                    <dt>{{Player.Meta.Name}}</dt>
                    <dd>
                        <h3>Stats</h3>
                        <ul>
                            <li>Health: {{Player.Health.Value}}/{{Player.Health.Max}}</li>
                            <li>Energy: {{Player.Energy.Value}}/{{Player.Energy.Max}}</li>
                        </ul>
                    </dd>
                    <dd>
                        
                    </dd>
                    <dd ng-hide="Player.Effects.length == 0">
                        <h3>Effects</h3>
                        <ul>
                            <li ng-repeat="Effect in Player.Effects">Effect {{Effect.Time}}</li>
                        </ul>
                    </dd>
                </dl>
            </div>
        
        </div>


<script>

angular.module("Game", ["ngAnimate", "ngRoute"])
.factory("Util", [function()
{
    var util = {};
    util.ArrayRemove = function(inArray, inObject)
    {
        var i;
        for(i=0; i<inArray.length; i++)
        {
            if(inArray[i] == inObject)
            {
                return inArray.splice(i, 1)[0];
            }
        }
    };
    util.ArrayClone = function(inArray)
    {
        var index;
        var out = [];
        for(i=0; i<inArray.length; i++)
        {
            out.push(inArray[i]);
        }
        return out;
    };
    util.ArrayJumble = function(inArray)
    {
        var index;
        var out = [];
        while(inArray.length != 0)
        {
            index = Math.floor(Math.random()*inArray.length);
            out.push(inArray.splice(index, 1)[0]);
        }
        return out;
    };
    return util;
}])
.factory("Name", [function()
{
    var name = {};

    name.Prefix = ["Xyrp", "Umeg", "Biyn", "Elor", "Kai", "Kha", "Talan", "Sae", "Iol", "Tan", "Marle", "Ves", "Inia", "Za", "Ela", "Pre", "Tor", "Chae", "Naex", "Daer", "Del", "Elin", "Taern"];
    name.Suffix = ["shin", "lu", "natar", "vel", "rath", "nyll", "vaur", "taar", "enth", "stan", "or", "mar", "eiros", "balar", "tris", "alim", "ora", "nore", "etor", "shandra", "cia", "imnda", "caryn", "arieth"];
    name.RandPrefix = function()
    {
        return name.Prefix[Math.floor(Math.random()*name.Prefix.length)];
    };
    name.RandSuffix = function()
    {
        return name.Suffix[Math.floor(Math.random()*name.Suffix.length)];
    };
    name.Generate = function()
    {
        var extra = "";
        if(Math.random() < 0.3)
        {
            extra = name.RandSuffix();
        }

        return name.RandPrefix()+name.RandSuffix()+extra;
    }

    return name;
}])
.factory("Stat", [function()
{
    var stat = {};
    stat.Instances = [];
    stat.SaveIndex = -1;
    stat.Save = function()
    {
        var i;
        var st;
        for(i=0; i<stat.Instances.length; i++)
        {
            st = stat.Instances[i];
            st.History.push({
                Min:st.Min,
                Max:st.Max,
                Value:st.Value
            });
        }
        stat.SaveIndex++;
        return stat.SaveIndex;
    };
    stat.Load = function(inIndex)
    {
        var i;
        for(i=0; i<stat.Instances.length; i++)
        {
            var st = stat.Instances[i];
            var history = st.History[inIndex];

            st.Min = history.Min;
            st.Max = history.Max;
            st.Value = history.Value;
        }
    };
    stat.Flush = function()
    {
        var i;
        for(i=0; i<stat.Instances.length; i++)
        {
            stat.Instances[i].History = [];
        } 
    };
    stat.Pop = function()
    {
        
    }
    stat.Create = function(inMin, inValue, inMax)
    {
        var obj = {
            Min: inMin,
            Max: inMax,
            Value: inValue,
            History: []
        };
        obj.Clip = function()
        {
            if(obj.Value < obj.Min)
            {
                obj.Value = obj.Min;
            }
            if(obj.Value > obj.Max)
            {
                obj.Value = obj.Max;
            }
        };
        obj.RelCheck = function(inValue)
        {
            inValue += obj.Value;
            if(inValue < obj.Min)
            {
                return inValue - obj.Min;
            }
            if(inValue > obj.Max)
            {
                return inValue - obj.Max;
            }
            return 0;
        };
        obj.Abs = function(inValue)
        {
            obj.Value = inValue;
            obj.Clip();
        };
        obj.Rel = function(inValue)
        {
            obj.Value += inValue;
            obj.Clip();
        };
        obj.Percent = function()
        {
            return (obj.Value - obj.Min)/(obj.Max - obj.Min) * 100 || 0;
        };
        stat.Instances.push(obj);
        return obj;
    };
    return stat;
}])
.factory("Energy", ["Stat", function(Stat)
{
    var energy = [];
    energy.push(Stat.Create(0, 3, 10));
    energy.push(Stat.Create(0, 3, 10));
    energy.push(Stat.Create(0, 3, 10));
    energy.push(Stat.Create(0, 3, 10));
    return energy;
}])
.factory("Player", ["Util", "Stat", "Selection", function(Util, Stat, Selection)
{
    var player = {};

    player.Create = function(inMeta)
    {
        var obj = {};
        obj.Meta = inMeta;
        obj.Health = Stat.Create(0, 10, 10);
        obj.Energy = Stat.Create(0, 0, 5);
        obj.Active = false;
        obj.Dead = false;
        obj.Incapacitated = false;
        obj.Targeted = false;

        obj.Playable = function()
        {
            if(obj.Dead || obj.Incapacitated)
            {
                return false;
            }
            return true;
        };

        obj.Abilities = [];
        obj.Effects = [];
        obj.Targets = [];
        obj.Queue = [];

        obj.QueuePush = function(inDo, inUndo, inCommit, inMeta)
        {
            if(obj.Energy.RelCheck(-1) != 0)
            {
                return;
            }
            var q = {
                Meta: inMeta,
                Save : Stat.Save(),
                Do: inDo,// do and undo are for removing effects
                Undo: inUndo,
                Commit: inCommit
            };
            q.Do();
            obj.Queue.push(q);
            obj.Energy.Rel(-1);
        };
        obj.QueuePop = function()
        {
            var last = obj.Queue.pop();
            last.Undo();
            Stat.Load(last.Save);
            Selection.Stop();
        };
        obj.QueueCharge = function(inAbility)
        {
            obj.QueuePush(inAbility.Charge, function(){}, function(){}, {Message:"Charging " + inAbility.Meta.Name});
        };
        obj.QueueCast = function(inAbility, inTargets)
        {
            function fDo()
            {
                inAbility.Cast(inTargets);
            };
            function fUndo()
            {
                var i;
                for(i=0; i<inTargets.length; i++)
                {
                    inTargets[i].Effects.pop();
                }
            };

            obj.QueuePush(fDo, fUndo, function(){}, {Message:"Casting " + inAbility.Meta.Name, Targets:inTargets});
        };


        obj.CheckHealth = function()
        {
            if(obj.Health.Percent() < 20)
            {
                obj.Incapacitated = true;
                if(obj.Health.Percent() == 0)
                {
                    obj.Dead = true;
                }
            }
            else
            {
                obj.Incapacitated = false;
                obj.Dead = false;
            }
        };

        obj.Effect = function(inEffect)
        {
            inEffect.Apply(obj);
            obj.Effects.push(inEffect);
            obj.CheckHealth();
        };

        obj.ApplyEffects = function()
        {
            // apply effects
            var i;
            var effect;
            for(i=0; i<obj.Effects.length; i++)
            {
                effect = obj.Effects[i];
                if(!effect.ApplyCheck())
                {
                    obj.Effects.splice(i, 1);
                    i--;
                }
                else
                {
                    effect.Apply(obj);
                }
            }

            // check for lethal effects
            obj.CheckHealth();
        };

        obj.Ability = function(inAbility)
        {
            inAbility.Player = obj;
            obj.Abilities.push(inAbility);
        };

        return obj;
    }

    return player;
}])
.factory("Effect", ["Stat", function(Stat)
{
    var effect = {};


    effect.Damage = function(inEffect)
    {
        inEffect.To.Health.Rel(-inEffect.Dole);
    };
    effect.Heal = function(inEffect)
    {
        inEffect.To.Health.Rel(inEffect.Dole);
    };
    effect.Intimidate = function(inEffect)
    {
        inEffect.To.Energy.Rel(-inEffect.Dole);
    };
    effect.Rally = function(inEffect)
    {
        inEffect.To.Energy.Rel(inEffect.Dole);
    };

    effect.Create = function(inPlayerFrom, inPlayerTo, inEfectFunction, inPower, inDuration)
    {
        var obj = {};
        obj.From = inPlayerFrom;
        obj.To = inPlayerTo;
        obj.Time = inDuration+1;
        obj.Net = inPower * (1 + (inDuration*0.1)); // total effect
        obj.Dole = obj.Net/obj.Time; // effect doled out per-tick
        obj.Function = inEfectFunction;

        obj.ApplyCheck = function()
        {
            if(obj.Time <= 0)
            {
                return false;
            }
            return true;
        }

        obj.Apply = function()
        {
            obj.Function(obj);
            obj.Time--;
        };

        obj.Remove = function()
        {
            var i;
            for(i=0; i<obj.From.Effects.length; i++)
            {
                if(obj.From.Effects[i] == obj)
                {
                    obj.From.Effects.splice(i, 1);
                    return;
                }
            }
        };

        return obj;
    };

    return effect;
}])
.factory("Ability", ["Util", "Energy", "Stat", "Effect", function(Util, Energy, Stat, Effect)
{
    var ability = {};
    ability.Random = function(inPower)
    {
        var i;
        var deltas = [];
        var left = Math.ceil(Math.random() * (Energy.length-1));
        var right = Energy.length - left;
        var leftIndex;
        var rightIndex;

        for(i=0; i<Energy.length; i++)
        {
            deltas[i] = 0;
        }
        for(i=0; i<inPower; i++)
        {
            leftIndex = Math.floor(left*Math.random());
            rightIndex = left + Math.floor(right*Math.random());
            deltas[leftIndex]--;
            deltas[rightIndex]++;
        }
        return Util.ArrayJumble(deltas);
    };
    ability.Create = function(inDeltas, inType, inMeta)
    {
        var i;
        var obj = {};
        obj.Meta = inMeta;
        obj.Player = {};
        obj.Charges = Stat.Create(0, 0, 3);
        obj.Power = 0;
        obj.Duration = 0;
        obj.Type = inType;
        obj.Deltas = inDeltas;
        obj.Selected = false;
        for(i=0; i<obj.Deltas.length; i++)
        {
            if(obj.Deltas[i] > 0)
            {
                obj.Power += obj.Deltas[i];
            }
        }

        obj.CheckCharge = function()
        {
            var i;
            var miss;
            var out = {
                Error:false,
                Message:"OK",
                Overshoot:[]
            };
            for(i=0; i<obj.Deltas.length; i++)
            {
                miss = Energy[i].RelCheck(obj.Deltas[i]);
                out.Overshoot.push(miss);

                if(miss != 0)
                {
                    out.Error = true;
                }
            }

            if(obj.Player.Energy.Percent() == 0)
            {
                out.Error = true;
                out.Message = "No Energy Left";
            }

            if(obj.Charges.Percent() == 100)
            {
                out.Error = true;
                out.Message = "Max Charges";
            }

            return out;
        };

        obj.Charge = function()
        {
            for(i=0; i<obj.Deltas.length; i++)
            {
                Energy[i].Rel(obj.Deltas[i]);
            }
            obj.Charges.Rel(1);
        };

        obj.Cast = function(inTargets)
        {
            var i;
            var effect;
            for(i=0; i<inTargets.length; i++)
            {
                effect = Effect.Create(obj.Player, inTargets[i], obj.Type, obj.Power*(obj.Charges.Value+1), obj.Duration);
                inTargets[i].Effect(effect);
            }
            obj.Charges.Abs(0);
        };

        return obj;
    };
    return ability;
}])
.factory("Team", [function()
{
    var team = {};
    team.Create = function()
    {
        var team = {};
        return team;
    }; 
    return team;
}])
.factory("Round", ["Util", "Stat", function(Util, Stat)
{
    var round = {};

    round.Create = function(inPlayers)
    {
        var obj = {};
        obj.Epoch = 0;
        obj.Index = false;
        obj.Player = false;
        obj.Players = Util.ArrayClone(inPlayers);

        obj.Reset = function()
        {
            obj.Epoch++;
            obj.Index = -1;
            obj.Player = false;
            obj.Players = Util.ArrayJumble(obj.Players);
            obj.Advance();
        };

        obj.Advance = function()
        {
            // clear the active player
            if(obj.Player)
            {
                obj.Player.Active = false;
                obj.Player.Queue = [];
                Stat.Flush();
            }

            //check for round end
            obj.Index++;
            if(obj.Index >= obj.Players.length)
            {
                obj.Reset();
                return;
            }

            
            obj.Player = obj.Players[obj.Index];
            if(obj.Player.Dead)
            {
                obj.Advance();
            }
            else
            {
                console.log("thhis player with", obj.Player.Health.Value, "health is not dead");
                obj.Player.ApplyEffects();
                if(obj.Player.Incapacitated)
                {
                    // if the player is (or is still) incapacitated after the effects are done, skip them
                    obj.Advance();
                }
                else
                {
                    // if the player is still not incapacitated, give them energy for their return
                    obj.Player.Active = true;
                    obj.Player.Energy.Rel(3);
                }
            }
        };

        obj.Reset();
        return obj;
    };

    return round;
}])
.factory("Selection", [function()
{
    var selection = {
        Targets:[],
        Ability:{},
        Open:false,
        Start:function(inAbility)
        {
            selection.Stop();

            inAbility.Selected = true;
            selection.Open = true;
            selection.Ability = inAbility;
        },
        Stop:function()
        {
            var i;
            for(i=0; i<selection.Targets.length; i++)
            {
                selection.Targets[i].Targeted = false;
            }
            selection.Ability.Selected = false;
            selection.Ability = {};
            selection.Targets = [];
            selection.Open = false;
        },
        Toggle:function(inTarget)
        {
            if(!selection.Open)
            {
                return;
            }
            if(inTarget.Targeted)
            {
                var i;
                for(i=0; i<selection.Targets.length; i++)
                {
                    if(selection.Targets[i] == inTarget)
                    {
                        inTarget.Targeted = false;
                        selection.Targets.splice(i, 1);
                    }
                }
            }
            else
            {
                inTarget.Targeted = true;
                selection.Targets.push(inTarget);
            }
        }
    };
    return selection;
}])
.controller("GameController", ["$scope", "Player", "Round", "Ability", "Effect", "Selection", "Name", function($scope, Player, Round, Ability, Effect, Selection, Name)
{
    $scope.Players = [];
    $scope.TeamA = [];
    $scope.TeamB = [];

    $scope.Selection = Selection;

    function CreatePlayer()
    {
        var player;
        player = Player.Create({Name: Name.Generate()});
        player.Ability(Ability.Create(Ability.Random(1), Effect.Damage, {Name:"Basic Damage 1"}));
        player.Ability(Ability.Create(Ability.Random(1), Effect.Damage, {Name:"Basic Damage 2"}));
        player.Ability(Ability.Create(Ability.Random(1), Effect.Damage, {Name:"Basic Damage 3"}));
        player.Ability(Ability.Create(Ability.Random(3), Effect.Damage, {Name:"Strong Damage 1"}));
        player.Ability(Ability.Create(Ability.Random(3), Effect.Damage, {Name:"Strong Damage 2"}));
        player.Ability(Ability.Create(Ability.Random(3), Effect.Damage, {Name:"Strong Damage 3"}));
        $scope.Players.push(player);
        return player;
    }

    $scope.TeamA[0] = CreatePlayer();
    $scope.TeamA[1] = CreatePlayer();
    $scope.TeamA[2] = CreatePlayer();

    $scope.TeamB[0] = CreatePlayer();
    $scope.TeamB[1] = CreatePlayer();
    $scope.TeamB[2] = CreatePlayer();

    $scope.Round = Round.Create($scope.Players);

}]);

</script>

    </body>
</html>