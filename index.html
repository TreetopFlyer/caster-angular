<!DOCTYPE html>
<html>
    <head>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular-route.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.6/angular-animate.min.js"></script>
        <style>
            dl
            {
                width:200px;
                float:left;
            }
            dl.Active
            {
                background:#FA0;
            }
        </style>
    </head>
    <body>
        <div ng-app="Game" ng-controller="GameController">
            <h3>Round: {{Round.Epoch}} Turn: {{Round.Index}}</h3>
            <div>
                <h4>Current Player</h4>
                <button ng-click="Round.Advance()">End Turn</button>
                <table>
                    <tr>
                        <th>Delta</th>
                        <th>Power</th>
                        <th>Duration</th>
                        <th>Charges</th>
                        <th>Status</th>
                    </tr>
                    <tr ng-repeat="Ability in Round.Player.Abilities">
                        <td>{{Ability.Deltas}}</td>
                        <td>{{Ability.Power}}</td>
                        <td>{{Ability.Duration}}</td>
                        <td>{{Ability.Charges.Value}}</td>
                        <td>
                            <button ng-click="Round.Player.QueueCharge(Ability)">Charge</button>    
                            <button ng-click="Round.Player.QueueCast(Ability, Targets)">Cast</button>    
                        </td>
                    </tr>
                </table>
                <hr/>
                <ul>
                    <li ng-repeat="Thing in Round.Player.Queue track by $index">
                        <span>{{Thing.Meta.Message}}</span>
                    </li>
                </ul>
                <div ng-hide="Round.Player.Queue.length == 0">
                    <button ng-click="Round.Player.QueuePop()">Undo Last</button>
                    <button ng-click="">Commit All</button>
                </div>
                <hr/>
            </div>
            <dl ng-repeat="Player in Players" ng-class="{Active: Player.Active}">
                <dt>Player</dt>
                <dd>
                    <h3>Stats</h3>
                    <ul>
                        <li>Health: {{Player.Health.Value}}/{{Player.Health.Max}}</li>
                        <li>Energy: {{Player.Energy.Value}}/{{Player.Energy.Max}}</li>
                    </ul>
                </dd>
                <dd>
                    
                </dd>
                <dd ng-hide="Player.Effects.length == 0">
                    <h3>Effects</h3>
                    <ul>
                        <li ng-repeat="Effect in Player.Effects">Effect {{Effect.Time}}</li>
                    </ul>
                </dd>
            </dl>
        </div>


<script>
angular.module("Game", ["ngAnimate", "ngRoute"])
.factory("Util", [function()
{
    var util = {};
    util.ArrayRemove = function(inArray, inObject)
    {
        var i;
        for(i=0; i<inArray.length; i++)
        {
            if(inArray[i] == inObject)
            {
                return inArray.splice(i, 1)[0];
            }
        }
    };
    util.ArrayClone = function(inArray)
    {
        var index;
        var out = [];
        for(i=0; i<inArray.length; i++)
        {
            out.push(inArray[i]);
        }
        return out;
    };
    util.ArrayJumble = function(inArray)
    {
        var index;
        var out = [];
        while(inArray.length != 0)
        {
            index = Math.floor(Math.random()*inArray.length);
            out.push(inArray.splice(index, 1)[0]);
        }
        return out;
    };
    return util;
}])
.factory("Stat", [function()
{
    var stat = {};
    stat.Instances = [];
    stat.SaveIndex = -1;
    stat.Save = function()
    {
        var i;
        var st;
        for(i=0; i<stat.Instances.length; i++)
        {
            st = stat.Instances[i];
            st.History.push({
                Min:st.Min,
                Max:st.Max,
                Value:st.Value
            });
        }
        stat.SaveIndex++;
        return stat.SaveIndex;
    };
    stat.Load = function(inIndex)
    {
        var i;
        for(i=0; i<stat.Instances.length; i++)
        {
            var st = stat.Instances[i];
            var history = st.History[inIndex];

            st.Min = history.Min;
            st.Max = history.Max;
            st.Value = history.Value;
        }
    };
    stat.Flush = function()
    {
        var i;
        for(i=0; i<stat.Instances.length; i++)
        {
            stat.Instances[i].History = [];
        } 
    };
    stat.Pop = function()
    {
        
    }
    stat.Create = function(inMin, inValue, inMax)
    {
        var obj = {
            Min: inMin,
            Max: inMax,
            Value: inValue,
            History: []
        };
        obj.Clip = function()
        {
            if(obj.Value < obj.Min)
            {
                obj.Value = obj.Min;
            }
            if(obj.Value > obj.Max)
            {
                obj.Value = obj.Max;
            }
        };
        obj.RelCheck = function(inValue)
        {
            inValue += obj.Value;
            if(inValue < obj.Min)
            {
                return inValue - obj.Min;
            }
            if(inValue > obj.Max)
            {
                return inValue - obj.Max;
            }
            return 0;
        };
        obj.Abs = function(inValue)
        {
            obj.Value = inValue;
            obj.Clip();
        };
        obj.Rel = function(inValue)
        {
            obj.Value += inValue;
            obj.Clip();
        };
        obj.Percent = function()
        {
            return (obj.Value - obj.Min)/(obj.Max - obj.Min) * 100 || 0;
        };
        stat.Instances.push(obj);
        return obj;
    };
    return stat;
}])
.factory("Energy", ["Stat", function(Stat)
{
    var energy = [];
    energy.push(Stat.Create(0, 3, 10));
    energy.push(Stat.Create(0, 3, 10));
    energy.push(Stat.Create(0, 3, 10));
    energy.push(Stat.Create(0, 3, 10));
    return energy;
}])
.factory("Player", ["Util", "Stat", function(Util, Stat)
{
    var player = {};

    player.Create = function()
    {
        var obj = {};
        obj.Health = Stat.Create(0, 100, 100);
        obj.Energy = Stat.Create(0, 0, 5);
        obj.Active = false;
        obj.Dead = false;
        obj.Incapacitated = false;

        obj.Playable = function()
        {
            if(obj.Dead || obj.Incapacitated)
            {
                return false;
            }
            return true;
        };

        obj.Abilities = [];
        obj.Effects = [];
        obj.Targets = [];
        obj.Queue = [];

        obj.QueuePush = function(inDo, inUndo, inCommit, inMeta)
        {
            var q = {
                Meta: inMeta,
                Save : Stat.Save(),
                Do: inDo,
                Undo: inUndo,
                Commit: inCommit
            };
            q.Do();
            obj.Queue.push(q);
        };
        obj.QueuePop = function()
        {
            var last = obj.Queue.pop();
            last.Undo();
            Stat.Load(last.Save);
        };
        obj.QueueCharge = function(inAbility)
        {
            obj.QueuePush(inAbility.Charge, function(){}, function(){}, {Message:"Charging " + inAbility.Meta.Name});
        };
        obj.QueueCast = function(inAbility, inTargets)
        {
            function fDo()
            {
                inAbility.Cast(inTargets);
            };
            function fUndo()
            {
                var i;
                for(i=0; i<inTargets.length; i++)
                {
                    inTargets[i].Effects.pop();
                }
            };

            obj.QueuePush(fDo, fUndo, function(){}, {Message:"Casting " + inAbility.Meta.Name, Targets:inTargets});
        };


        obj.CheckHealth = function()
        {
            if(obj.Health.Percent < 20)
            {
                obj.Incapacitated = true;
                if(obj.Health.Percent() == 0)
                {
                    obj.Dead = true;
                }
            }
            else
            {
                obj.Incapacitated = false;
                obj.Dead = false;
            }
        };

        obj.Effect = function(inEffect)
        {
            inEffect.Apply(obj);
            obj.Effects.push(inEffect);
            obj.CheckHealth();
        };

        obj.ApplyEffects = function()
        {
            // apply effects
            var i;
            var effect;
            for(i=0; i<obj.Effects.length; i++)
            {
                effect = obj.Effects[i];
                if(!effect.ApplyCheck())
                {
                    obj.Effects.splice(i, 1);
                    i--;
                }
                else
                {
                    effect.Apply(obj);
                }
            }

            // check for lethal effects
            obj.CheckHealth();
        };

        obj.Ability = function(inAbility)
        {
            inAbility.Player = obj;
            obj.Abilities.push(inAbility);
        };

        return obj;
    }

    return player;
}])
.factory("Effect", ["Stat", function(Stat)
{
    var effect = {};


    effect.Damage = function(inEffect)
    {
        inEffect.To.Health.Rel(-inEffect.Dole);
    };
    effect.Heal = function(inEffect)
    {
        inEffect.To.Health.Rel(inEffect.Dole);
    };
    effect.Intimidate = function(inEffect)
    {
        inEffect.To.Energy.Rel(-inEffect.Dole);
    };
    effect.Rally = function(inEffect)
    {
        inEffect.To.Energy.Rel(inEffect.Dole);
    };

    effect.Create = function(inPlayerFrom, inPlayerTo, inEfectFunction, inPower, inDuration)
    {
        var obj = {};
        obj.From = inPlayerFrom;
        obj.To = inPlayerTo;
        obj.Time = inDuration+1;
        obj.Net = inPower * (1 + (inDuration*0.1)); // total effect
        obj.Dole = obj.Net/obj.Time; // effect doled out per-tick
        obj.Function = inEfectFunction;

        obj.ApplyCheck = function()
        {
            if(obj.Time <= 0)
            {
                return false;
            }
            return true;
        }

        obj.Apply = function()
        {
            obj.Function(obj);
            obj.Time--;
        };

        obj.Remove = function()
        {
            var i;
            for(i=0; i<obj.From.Effects.length; i++)
            {
                if(obj.From.Effects[i] == obj)
                {
                    obj.From.Effects.splice(i, 1);
                    return;
                }
            }
        };

        return obj;
    };

    return effect;
}])
.factory("Ability", ["Energy", "Stat", "Effect", function(Energy, Stat, Effect)
{
    var ability = {};
    ability.Random = function(inPower)
    {
        var i;
        var out = [];
        var openPos = [];
        var openNeg = [];
        for(i=0; i<Energy.length; i++)
        {
            openPos.push(i);
            openNeg.push(i);
            out.push(0);
        }
        for(i=0; i<inPower; i++)
        {
            var index;

            index = Math.random()*openPos.length;
            out[openPos[index]]++;
            openNeg.splice(index, 1);

            index = Math.random()*openNeg.length;
            out[openNeg[index]]--;
            openNeg.splice(index, 1);
        }
    };
    ability.Create = function(inDeltas, inType, inMeta)
    {
        var i;
        var obj = {};
        obj.Meta = inMeta;
        obj.Player = {};
        obj.Charges = Stat.Create(0, 0, 3);
        obj.Power = 0;
        obj.Duration = 0;
        obj.Type = inType;
        obj.Deltas = inDeltas;

        for(i=0; i<obj.Deltas.length; i++)
        {
            if(obj.Deltas[i] > 0)
            {
                obj.Power += obj.Deltas[i];
            }
        }

        obj.CheckCharge = function()
        {
            var i;
            var miss;
            var out = {
                Error:false,
                Message:"OK",
                Overshoot:[]
            };
            for(i=0; i<obj.Deltas.length; i++)
            {
                miss = Energy[i].RelCheck(obj.Deltas[i]);
                out.Overshoot.push(miss);

                if(miss != 0)
                {
                    out.Error = true;
                }
            }

            if(obj.Player.Energy.Percent() == 0)
            {
                out.Error = true;
                out.Message = "No Energy Left";
            }

            if(obj.Charges.Percent() == 100)
            {
                out.Error = true;
                out.Message = "Max Charges";
            }

            return out;
        };

        obj.Charge = function()
        {
            for(i=0; i<obj.Deltas.length; i++)
            {
                Energy[i].Rel(obj.Deltas[i]);
            }
            obj.Charges.Rel(1);
        };

        obj.Cast = function(inTargets)
        {
            var i;
            var effect;
            for(i=0; i<inTargets.length; i++)
            {
                effect = Effect.Create(obj.Player, inTargets[i], obj.Type, obj.Power*(obj.Charges.Value+1), obj.Duration);
                inTargets[i].Effect(effect);
            }
            obj.Charges.Abs(0);
        };

        return obj;
    };
    return ability;
}])
.factory("Team", [function()
{
    var team = {};
    team.Create = function()
    {
        var team = {};
        return team;
    }; 
    return team;
}])
.factory("Round", ["Util", "Stat", function(Util, Stat)
{
    var round = {};

    round.Create = function(inPlayers)
    {
        var obj = {};
        obj.Epoch = 0;
        obj.Index = false;
        obj.Player = false;
        obj.Players = Util.ArrayClone(inPlayers);

        obj.Reset = function()
        {
            obj.Epoch++;
            obj.Index = -1;
            obj.Player = false;
            obj.Players = Util.ArrayJumble(obj.Players);
            obj.Advance();
        };

        obj.Advance = function()
        {
            // clear the active player
            if(obj.Player)
            {
                obj.Player.Active = false;
                obj.Player.Queue = [];
                Stat.Flush();
            }

            //check for round end
            obj.Index++;
            if(obj.Index >= obj.Players.length)
            {
                obj.Reset();
                return;
            }

            
            obj.Player = obj.Players[obj.Index];
            if(obj.Player.Dead)
            {
                obj.Advance();
            }
            else
            {
                obj.Player.ApplyEffects();
                if(obj.Player.Incapacitated)
                {
                    // if the player is (or is still) incapacitated after the effects are done, skip them
                    obj.Advance();
                }
                else
                {
                    // if the player is still not incapacitated, give them energy for their return
                    obj.Player.Active = true;
                    obj.Player.Energy.Rel(3);
                }
            }
        };

        obj.Reset();
        return obj;
    };

    return round;
}])
.controller("GameController", ["$scope", "Player", "Round", "Ability", "Effect", function($scope, Player, Round, Ability, Effect)
{
    $scope.Players = [];
    $scope.TeamA = [];
    $scope.TeamB = [];
    $scope.Targets = [];

    function CreatePlayer()
    {
        var player;
        player = Player.Create();
        player.Ability(Ability.Create([-1, 1, 0, 0], Effect.Damage, {Name:"Basic Damage 1"}));
        player.Ability(Ability.Create([0, -1, 1, 0], Effect.Damage, {Name:"Basic Damage 2"}));
        player.Ability(Ability.Create([0, 0, -1, 1], Effect.Damage, {Name:"Basic Damage 3"}));
        player.Ability(Ability.Create([1, 0, 0, -1], Effect.Damage, {Name:"Basic Damage 4"}));
        $scope.Players.push(player);
        return player;
    }

    $scope.TeamA[0] = CreatePlayer();
    $scope.TeamA[1] = CreatePlayer();
    $scope.TeamA[2] = CreatePlayer();

    $scope.TeamB[0] = CreatePlayer();
    $scope.TeamB[1] = CreatePlayer();
    $scope.TeamB[2] = CreatePlayer();

    $scope.Round = Round.Create($scope.Players);

    //////////////
    $scope.Targets = $scope.TeamB;
    $scope.TeamA[0].Abilities[0].Cast($scope.Targets);

}]);


</script>

    </body>
</html>